# Parquet to JSON Converter for Go Projects

Convert query vectors from parquet format to Go-compatible JSON for high-performance vector search applications.

## 🎯 Overview

This toolkit provides seamless conversion between:
- **Input**: Parquet files with `feature` column (generated by `generate_query_vectors.py`)
- **Output**: JSON files compatible with Go `[][]float32` type

## 📁 Files Included

| File | Purpose |
|------|---------|
| `convert_parquet_to_json.py` | Main conversion script (Python) |
| `load_query_vectors.go` | Simple Go loader with examples |
| `json_vector_usage_example.go` | Advanced Go usage with concurrency |

## 🚀 Quick Start

### Step 1: Generate Query Vectors (if needed)
```bash
# Generate 10,000 query vectors from feature parquet files
python3 generate_query_vectors.py /path/to/feature/parquet/files/
# Output: /tmp/query.parquet
```

### Step 2: Convert to JSON
```bash
# Convert parquet to Go-compatible JSON
python3 convert_parquet_to_json.py /tmp/query.parquet /tmp/query_vectors.json
```

**Output:**
```
📊 Conversion completed successfully!
📁 Output file: /tmp/query_vectors.json
📊 Total vectors: 10,000
📊 Dimensions: [768]
📁 File size: 177.83 MB
```

### Step 3: Use in Go Applications
```go
// Simple loading
package main

import "fmt"

func main() {
    queries, err := LoadQueryVectorsFromJSON("/tmp/query_vectors.json")
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Loaded %d vectors\n", len(queries))
    
    // Get some vectors for search
    vectors := queries.GetVectorsSlice(0, 5)
    fmt.Printf("Retrieved %d vectors for search\n", len(vectors))
}
```

## 📊 Performance Comparison

### File Size Comparison
| Format | Size | Load Time | Memory Usage |
|--------|------|-----------|--------------|
| **Parquet** | 59MB | ~2s | ~150MB |
| **JSON** | 178MB | ~3s | ~200MB |

*Note: JSON is larger but provides faster Go parsing*

### Load Performance (10,000 vectors)
| Operation | Time | Memory |
|-----------|------|--------|
| **Parquet → JSON conversion** | 13s | ~500MB |
| **JSON → Go loading** | 2s | ~200MB |
| **Vector retrieval (1000x)** | <1ms | Minimal |

## 🔧 Detailed Usage

### Python Conversion Script

```bash
# Basic usage
python3 convert_parquet_to_json.py <input.parquet> <output.json>

# Real example
python3 convert_parquet_to_json.py \
    /root/test/data/query.parquet \
    /root/test/data/query_vectors.json
```

**Features:**
- ✅ **Validation**: Checks vector format and dimensions
- ✅ **Error Handling**: Graceful handling of invalid vectors
- ✅ **Progress Logging**: Real-time conversion progress
- ✅ **Verification**: Automatic output validation

### Go Vector Loading

#### Simple Usage
```go
// Load vectors
queries, err := LoadQueryVectorsFromJSON("/path/to/query_vectors.json")

// Get vectors for search
searchVectors := queries.GetVectorsSlice(0, 10)  // Get 10 vectors starting from index 0
```

#### Thread-Safe Usage
```go
// Create thread-safe manager
manager := NewQueryVectorManager()
err := manager.LoadFromJSON("/path/to/query_vectors.json")

// Use in concurrent goroutines
go func() {
    vectors := manager.GetVectors(5)  // Thread-safe
    // Use vectors for search...
}()
```

#### Advanced Usage with Statistics
```go
manager := NewQueryVectorManager()
manager.LoadFromJSON("/tmp/query_vectors.json")

// Get statistics
stats := manager.GetStats()
fmt.Printf("Total vectors: %v\n", stats["total_vectors"])
fmt.Printf("Dimensions: %v\n", stats["dimension_counts"])
```

## 🏃 Concurrency Example

Run the provided concurrency example:

```bash
go run json_vector_usage_example.go
```

**Sample Output:**
```
📊 Test Case 3: 20 workers × 25 tasks
🚀 Starting 20 workers, 25 tasks each...
✅ Search 1 completed: 1 vectors, 768 dims, took 11.311ms (total: 269)
✅ Search 2 completed: 1 vectors, 768 dims, took 11.108ms (total: 286)
📊 Completed 500 searches in 275.169ms (1817.06 QPS)
```

**Performance Highlights:**
- **1,817 QPS** for simulated search operations
- **Thread-safe** vector cycling
- **Automatic memory management**
- **Real-time statistics**

## 💡 Integration Tips

### 1. Production Applications
```go
// Load vectors once at application startup
var globalQueryVectors *QueryVectorManager

func init() {
    globalQueryVectors = NewQueryVectorManager()
    err := globalQueryVectors.LoadFromJSON("/etc/app/query_vectors.json")
    if err != nil {
        log.Fatal("Failed to load query vectors:", err)
    }
}

// Use in search handlers
func searchHandler(w http.ResponseWriter, r *http.Request) {
    queryVectors := globalQueryVectors.GetVectors(1)
    // Perform Milvus search with queryVectors...
}
```

### 2. High-Performance Search Testing
```go
// For load testing with rotating vectors
func performLoadTest(client MilvusClient, vectorManager *QueryVectorManager) {
    for i := 0; i < 10000; i++ {
        vectors := vectorManager.GetVectors(1)
        
        // Perform search
        results, err := client.Search(
            collection="test_collection",
            data=vectors,
            // ... other parameters
        )
        
        // Process results...
    }
}
```

### 3. Memory-Efficient Large Datasets
```go
// For very large vector sets, consider chunked loading
type ChunkedVectorManager struct {
    chunks []Queries
    currentChunk int
}

func (cvm *ChunkedVectorManager) LoadChunks(filePattern string) error {
    // Load multiple JSON files as chunks
    // Rotate through chunks to save memory
}
```

## 🔍 Troubleshooting

### Common Issues

1. **"Required 'feature' column not found"**
   ```bash
   # Check parquet file structure
   python3 -c "
   import pandas as pd
   df = pd.read_parquet('/tmp/query.parquet')
   print('Columns:', list(df.columns))
   "
   ```

2. **"No valid vectors found"**
   ```bash
   # Check vector data types
   python3 -c "
   import pandas as pd
   df = pd.read_parquet('/tmp/query.parquet')
   print('First vector type:', type(df['feature'].iloc[0]))
   print('First vector shape:', len(df['feature'].iloc[0]))
   "
   ```

3. **Large File Sizes**
   - JSON files are ~3x larger than parquet
   - Consider gzip compression for storage:
   ```bash
   gzip /tmp/query_vectors.json
   # Load with: gunzip -c /tmp/query_vectors.json.gz
   ```

### Performance Optimization

1. **For Faster Loading**:
   - Use SSD storage for JSON files
   - Load vectors during application initialization
   - Consider memory mapping for very large files

2. **For Memory Efficiency**:
   - Use chunked loading for datasets > 1GB
   - Implement LRU cache for frequently used vectors
   - Monitor memory usage in production

## 📈 Use Cases

### Vector Search Performance Testing
Perfect for benchmarking Milvus/other vector databases with realistic query vectors.

### ML Pipeline Integration
Integrate with Go-based ML inference pipelines that need consistent query vectors.

### Microservice Architecture
Load vectors once in vector-serving microservices, share across multiple search instances.

### A/B Testing
Compare search results across different vector sets or algorithms.

## 🎉 Summary

This toolkit provides a seamless bridge between Python-generated parquet vectors and Go applications, enabling:

- **High-performance** vector search testing
- **Memory-efficient** vector management
- **Thread-safe** concurrent access
- **Production-ready** integration patterns

The conversion process is optimized for both development speed and production performance, making it ideal for serious vector search applications.
